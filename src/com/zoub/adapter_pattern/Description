一、适配器模式简介
1.定义
适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类
能够在一起工作。

2.定义阐述
适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。
也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，
客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。
这就是适配器模式的模式动机。

例子一：笔记本电脑的插头一般都是三相的，即除了阳极、阴极外，还有一个地极。而有些地方的电源插座却
只有两极，没有地极。电源插座与笔记本电脑的电源插头不匹配使得笔记本电脑无法使用。这时候一个三相到
两相的转换器（适配器）就能解决此问题，而这正像是本模式所做的事情。

例子二：
背景：小成买了一个进口的电视机
冲突：进口电视机要求电压（110V）与国内插座标准输出电压（220V）不兼容
解决方案：设置一个适配器将插座输出的220V转变成110V
====================================================================================================
二、适配器模式结构
适配器模式有  #类的适配器模式#  和  #对象的适配器模式#

#类适配器模式#
类的适配器模式把适配的类的API转换成为目标类的API

模式所涉及的角色有：
a.目标（Target）角色：这就是所期待得到的接口。注意：由于这里讨论的是类的适配器模式，因此目标不可以是类
b.源（adaptee）角色：现在需要适配的接口
c.适配器（Adapter）角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，
而必须是具体的类。
public interface Target {
    /**
     * 这是源类Adaptee也有的方法
     */
    public void sampleOperation1();
    /**
     * 这是源类Adapteee没有的方法
     */
    public void sampleOperation2();
}

public class Adaptee {

    public void sampleOperation1(){}

}

public class Adapter extends Adaptee implements Target {
    /**
     * 由于源类Adaptee没有方法sampleOperation2()
     * 因此适配器补充上这个方法
     */
    @Override
    public void sampleOperation2() {
        //写相关的代码
    }

}
------------------------------------------------------------------------------------------------------
#对象适配器模式#
与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，
对象的适配器模式不是使用继承关系链接到Adaptee类，而是使用委派关系链接到Adpatee类

三、类适配器和对象适配器的权衡
●　　类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。

●　　对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，
因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了。

●　　对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器
可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正
确，是不是子类都无所谓。

●　 对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。

●　 对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现
重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方
便的很，而且新增加的行为可同时适用于所有的源。

●　　对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。

●　　对于对象适配器，需要额外的引用来间接得到Adaptee。

建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来
选用实现方式，最适合的才是最好的。

4. 应用场景
4.1 适配器的使用场景
系统需要复用现有类，而该类的接口不符合系统的需求，可以使用适配器模式使得原本由于接口不兼容而
不能一起工作的那些类可以一起工作
多个组件功能类似，但接口不统一且可能会经常切换时，可使用适配器模式，使得客户端可以以统一的接
口使用它们
4.2 类和对象适配器模式的使用场景
灵活使用时：选择对象的适配器模式
类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。

需要同时配源类和其子类：选择对象的适配器

对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静
态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了；

对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和
它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都
无所谓。

需要重新定义Adaptee的部分行为：选择类适配器
对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。
对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，
然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。
仅仅希望使用方便时：选择类适配器
对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。
对于对象适配器，需要额外的引用来间接得到Adaptee。
